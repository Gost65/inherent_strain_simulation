# -*- coding: utf-8 -*-
"""My_InherentStrain_Draft.ipynb

Automatically generated by Colaboratory.

#**Introduction**
The goal of this code is to apply inherent strain to any dataset of *.stl* file. Written by:
- Pierre KERFRIDEN for Inherent strain function and Fenics installation
- Pierre LESBATS automatization

"""

#Run meshio installation:
!pip3 install meshio==4.0.3

import meshio

print('meshio installation is done with version',  meshio.__version__)
print('Restart runtime after install meshio')

#Run VTK installation:
!pip3 install vtk

import vtk

print('installation is done and you have',vtk.vtkVersion.GetVTKSourceVersion())

#Run FEniCS installation:
import platform, sys
python_version=platform.python_version()
from distutils.version import LooseVersion, StrictVersion

if ( LooseVersion(python_version) < LooseVersion("3.0.0")):
    print("Python3 is needed!");
    print("How to fix: Runtime/Change_runtime_type/Python 3");
    sys.exit()

try:
    import dolfin
except ImportError as e:
    !apt-get install -y -qq software-properties-common
    !echo deb http://ppa.launchpad.net/fenics-packages/fenics/ubuntu bionic main >> /etc/apt/sources.list
    !apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 2C5275D7EF63D9DE2D28D3702940F5212B746472
    !apt-get update -qq
    !apt install -y --no-install-recommends fenics
    !sed -i "s|#if PETSC_VERSION_MAJOR == 3 && PETSC_VERSION_MINOR <= 8 && PETSC_VERSION_RELEASE == 1|#if 1|" /usr/include/dolfin/la/PETScLUSolver.h
    !rm -rf /usr/lib/python3/dist-packages/mpi4py*
    !rm -rf /usr/lib/python3/dist-packages/petsc4py*
    !rm -rf /usr/lib/python3/dist-packages/slepc4py*
    !rm -rf /usr/lib/petsc/lib/python3/dist-packages/dolfin*
    !rm -rf /usr/lib/petsc/lib/python3/dist-packages/mshr*
    !wget "https://drive.google.com/uc?export=download&id=1cT_QBJCOW_eL3BThnval3bcpb8o0w-Ad" -O /tmp/mpi4py-2.0.0-cp37-cp37m-linux_x86_64.whl
    !wget "https://drive.google.com/uc?export=download&id=119i49bxlGn1mrnhTNmOvM4BqmjrT9Ppr" -O /tmp/petsc4py-3.7.0-cp37-cp37m-linux_x86_64.whl
    !wget "https://drive.google.com/uc?export=download&id=1-1tVfu8qz3bRC2zvR8n3RESpesWqNnn6" -O /tmp/slepc4py-3.7.0-cp37-cp37m-linux_x86_64.whl
    !wget "https://drive.google.com/uc?export=download&id=1-3qY4VIJQaXVO1HfGQIzTIURIeJbvX-9" -O /tmp/fenics_dolfin-2019.2.0.dev0-cp37-cp37m-linux_x86_64.whl
    !wget "https://drive.google.com/uc?export=download&id=1-5SMjgjMuee_9WLeYtGe8N_lvipWEN7W" -O /tmp/mshr-2019.2.0.dev0-cp37-cp37m-linux_x86_64.whl
    !pip3 install /tmp/mpi4py-2.0.0-cp37-cp37m-linux_x86_64.whl --upgrade
    !pip3 install /tmp/petsc4py-3.7.0-cp37-cp37m-linux_x86_64.whl --upgrade
    !pip3 install /tmp/slepc4py-3.7.0-cp37-cp37m-linux_x86_64.whl --upgrade
    !pip3 install /tmp/fenics_dolfin-2019.2.0.dev0-cp37-cp37m-linux_x86_64.whl --upgrade
    !pip3 install /tmp/mshr-2019.2.0.dev0-cp37-cp37m-linux_x86_64.whl --upgrade
    !pip3 -q install --upgrade sympy
    import dolfin
  
from IPython.display import clear_output, display; import time; import dolfin.common.plotting as fenicsplot 


#on confirme que dolphin, module de Fenics, est bien là
dolfin_version = dolfin.__version__
print ('Dolfin installation is done with version', dolfin_version)
#si y'a un soucis tu fait "Excécution -> redémarrer l'environnement d'excécution" et tu run a nouveau le code.
#!rm -rf * # clean up all files and Drive Be careful


# Useful commands
# Remove an empty folder      : os.rmdir("my_results")
# Remove a folder with files  : shutil.rmtree("results")
# Make a folder               : os.mkdir("my_results")
# Runtime/Change_runtime_type/Python3

#Because we have a problem with version' compatibility we hae to re install h5py
!pip3 uninstall -y h5py
!pip3 install h5py

#We import:
import os, sys, shutil, meshio
import datetime
import h5py
import hdf5

print('la version de h5py :',h5py.__version__)
print('la version de hdf5 de c mort :',hdf5.__version__)

import platform
print('Python version: ',platform.python_version())

!pip freeze > requirements.txt

"""# **2-Manage input data and external scripts**
We stock data and results on Google Drive.
"""

from google.colab import drive
#sortir le # si drive déjà monté
drive.mount('/content/drive')

"""We need to import "msh2xdmf.py" in order to convert *.msh* files for FEniCS utilsation."""

#We import msh2xdmf.py file which is on our local machine.
from google.colab import files

uploaded = files.upload()

print("Importation successfully")

"""# **3-Inherent Strain**
We begin by definning the Inherent Strain function.     
The function is split in 3 parts:
- 1) Converting *.msh* for FEniCS
- 2) Boundary condition 
- 3) Defining the IS function

In addition, we have also to define the work environment and create results files.
"""

'''
THIS BLOCK contains the inherent Strain:
'''

import os
import meshio
from msh2xdmf import msh2xdmf, import_mesh_from_xdmf
from dolfin import *
import numpy as np

 
def InherentStrain(in_folder,piece,out_folder,param):

  # -------------------- #
  #   Import mesh files  #
  # -------------------- #

  print('Converting',piece)
  #Transform mesh into fenics format
  msh2xdmf(piece, dim=3, directory=in_folder)
  # Run the import:
  mesh, boundaries, subdomains, labels = import_mesh_from_xdmf(
      prefix=str_name,
      dim=3,
      directory=in_folder,
      subdomains=True,
      )
  la=meshio.read(in_folder+'/'+piece)
  print('We can import the mesh, look: \n',mesh, 'and the dimension of the mesh is:',mesh.geometry().dim())
 

  # ------------------------- #
  #   Define the environment  #
  # ------------------------- #

  #Finite Element space definitions: the vector and the tensor function space
  V = VectorFunctionSpace(mesh, 'P', 1) #we put 1 to stop translation and rotation
  T = TensorFunctionSpace(mesh, 'DG', 0) #Discontinuous Lagrange 
  tol= 1E-14 # tolerance



  # -------------------- #
  #   Create boundaries  #
  # -------------------- #
  
  class BoundaryBottom_func(SubDomain):
    def inside(self, x, on_boundary):
      #x[2] is z axe, fixing bottom surface. 
      # return on_boundary and near(x[2], 2., tol) #no fix bottom regarde si on peut pas mettre une petite distance
      return on_boundary and x[2] <= 0.0 #fix bottom surface / Before cutting / We fix everything that is 0< or =0
      #return on_boundary and x[0] <=10.0 and x[1] <= 12.0 #partie massive fixe
    
  
  BoundaryBottom = BoundaryBottom_func() 

  #Set markers as 1 at bottom surface (for visualisation in para view)
  BoundaryMarker = MeshFunction("size_t", mesh, mesh.topology().dim() - 1) 

  BoundaryMarker = MeshFunction('size_t', mesh,dim=3)

  BoundaryMarker.set_all(0)
  BoundaryBottom.mark(BoundaryMarker, 1)

  #Dirichlet meaning: the values that a solution needs to take along the boundary of the domain. 
  bc = DirichletBC(V,
                   Constant((0.,0.,0.)),
                   BoundaryBottom)


  # ---------------- #
  #  Material param  #
  # ---------------- #

  #The material is : IN-718_powder 

  E = 191000  #Young's modulus (MPa) 
  nu = 0.31   #Poisson's ratio

  #Some constant
  lmbda = E*nu/((1.0 + nu)*(1.0 - 2.0*nu)) #first Lamé coefficient 
  mu = E/(2.0*(1.0 + nu)) #shear modulus


  # ---------------------------- #
  #   Plastic Strain definition  #
  # ---------------------------- #

 
  #Hooke's law in 3 dimensions
  def sigma(v):
    epsilon=sym(grad(v)) #definition of epsilion 
    n = len(v) #matrix order
    return 2.0*mu*epsilon + lmbda*tr(epsilon)*Identity(n) #formula


  #TASK Parametrisations of contractions on x (x[0]), y (x[1]), z(x[2]) using 4 parameters

  class InherentStrainFunc(UserExpression):
    def eval(self, value, x):
      #for the parameter utilization please refer the parameter document.
      value[0] = 0. 
      value[1] = 0. 
      value[2] = 0. 
      
      value[3] = 0. 
      value[4] = 0. 
      value[5] = 0. 

      value[6] = 0.
      value[7] = 0.
      value[8] = 0.

      #if x[2]>0.:
        # if you add 0 nothing appear
        # c'est ici qu'il faut jouer pour déformer, met un signe négatif pour que ça grandisse en partant d'en bas
        # de ce que l'on voit des partenaire les pièces ont tendances à de rétracter quand elles snt fixé au plateau

      value[0] = param[0]
      value[4] = param[0]
      value[8] = param[0]

  InherentStrain = InherentStrainFunc(element=T.ufl_element()) #create an object to apply deformations

  InherentStrainInterp = Function(T)
  print("value shape de l'is",InherentStrainInterp.value_shape())
        
  InherentStrainInterp.interpolate(InherentStrain)

  #Finite Element Analysis Section
  u = TrialFunction(V) #nodes displacement amount
  v = TestFunction(V)
  a  = inner(sigma(u), grad(v))*dx
  L = inner(InherentStrain,sym(grad(v)))*dx
        
  u_sol = Function(V) #we create the field of displacements

  #Solving the equation:
  solve(a == L, u_sol, bc) #solving the FEA analysis, within the boundaries defined previoulsy
  #TASK: u_sol is to be compared with target geometry to calculate the NN cost function, could be exported in NumPy to facilitate


  # ------------------ #
  #   IS application   #
  # ------------------ #

  coord = mesh.coordinates() #we get the coordinates of the part's mesh  
  #print('mesh coordinates before u_sol : \n',coord)
  
  
  v2d = vertex_to_dof_map(V)
  v2d = v2d.reshape((-1, mesh.geometry().dim()))
  #print('v2d.shape',v2d.shape)

  #we get the displacements' vector, displacements already calculated
  u_vector=u_sol.vector()
  values=u_vector.get_local() #values 
  #print(type(values),'type of values is','u_sol vector values : \n',values)
  
  #list with the coordinates of the mesh
  mesh_ini=[]

  for i in range(coord.shape[0]):

    mesh_ini.append([coord[i,0],coord[i,1],coord[i,2]])

    #X = V.dofmap().tabulate_all_coordinates(mesh)
    v2d_loc = v2d[i,:]
    #print(' v2d_loc', v2d_loc)
    #print('x[i,0]',coord[i,0])
    coord[i,0] = coord[i,0] + u_vector[v2d_loc[0]] #we apply the displacements' vector
    coord[i,1] = coord[i,1] + u_vector[v2d_loc[1]]
    coord[i,2] = coord[i,2] + u_vector[v2d_loc[2]]

  # we convert the list in array
  mesh_ini__array = np.array(mesh_ini)

  print("")  
  #print('mesh coordinates after u_sol : \n',coord)


  # ------------------------- #
  #   Generate results files  #
  # ------------------------- #

  print("")
  #Create mesh file for visualisation
  #file_mesh = File(out_folder+str_name+"_mesh.pvd")
  #file_mesh  << mesh

  #FileBoundaryMarker = File(out_folder+str_name+"_BoundaryMarker.pvd")
  #FileBoundaryMarker << BoundaryMarker

  #Save results in pvd file for visualisation in para view
  #InherentStrain_file = File(out_folder+str_name+"_InherentStrain.pvd")
  #InherentStrain_file << InherentStrainInterp

  #Save displacement result in txt file for Leopold
  #print('the matrix with (before - after) u_sol is: \n',mesh_ini__array - coord)
  np.savetxt(out_folder+str_name+'_def.txt', ( mesh_ini__array -coord), fmt='%10.5f' )
  #%10.5f: the 10 is number of decimal before the . and 5 the same but after the .

  #Save deformation result in pvd file
  file_displacement = File(out_folder+str_name+"_i000_j000_k001_Displacement.pvd")
  file_displacement << u_sol
  print("")
  print("Results files created with success")
  print("")

"""Now we apply the function to the dataset: """

'''
NORMAL CONFIG
'''

#We have here the path to the folder with the msh files and the path where we want the results:
dataset = 'drive/MyDrive/Fenics/Test/meshed'
results_folder = '/content/drive/MyDrive/Fenics/Test/results/'

#We have the parameters for the IS 
i = -775.28
#j = 5846.18 #for bending

parameters = [i, j, k]


#we want to apply the IS function to the dataset:
with os.scandir(dataset) as entries:
  my_optimi = []
  for my_msh in entries: #we scan the folder to get the .msh files
    shape=my_msh.name
    str_name,ext = os.path.splitext(shape)
    if ext =='.msh':
      my_optimi.append(str(shape))
      try: 
        InherentStrain(dataset,shape,results_folder,parameters)
      except Exception as exception:
        print(exception)
        print("this file has a problem")
        print("")
        pass

"""# **4-Results as .stl**
The following block is a converter to pass to *.vtu*, which is the result of the IS, to an *.stl* or *.obj* file. Inside the code, you have a selector to choose the format between *.stl* or *.obj*.
Keep the converter in *.stl* to use Shuo's code.
"""

'''
THIS BLOCK contains a vtk to stl converter
'''

import vtk

def converter(indir, outdir):
    files = os.listdir(indir)
    for f in files:
        if f.endswith('.vtu'): #we just cnvert .vtu files
            files = os.path.join(indir,f)
            reader = vtk.vtkXMLUnstructuredGridReader() #we read the .vtu file with this reader cause the .vtu file is a UnstructuredGrid type
            reader.SetFileName(files)
            reader.Update() # we ahve to update
            output = reader.GetOutput()
            fileName=f.split('.')[0]

              # ----------- #
              #   Selector  #
              # ----------- #
            
            extension = '.stl' #choose the type of output file: .stl or .obj
            the_converted = outdir + fileName + extension
            if extension == '.stl':
              writer = vtk.vtkSTLWriter() #we create the .stl file here
            if extension == '.obj':
              writer = vtk.vtkOBJWriter() #we create the .obj file here            
            writer.SetFileName(the_converted)

            surface_filter = vtk.vtkDataSetSurfaceFilter() #we extract the surface
            surface_filter.SetInputConnection(reader.GetOutputPort())
            triangle_filter = vtk.vtkTriangleFilter()
            triangle_filter.SetInputConnection(surface_filter.GetOutputPort())

            writer.SetInputConnection(triangle_filter.GetOutputPort())
            writer.Write() #we write the stl files

            if writer.Write() == 1:
              print(datetime.datetime.now())
              print("Conversion to",extension, 'is done. Look:' ,the_converted)

#We have here the path to the folder with the results files and the path where we want converted results:
results_fenics = '/content/drive/MyDrive/Fenics/Test/results/'
stl_converted = '/content/drive/MyDrive/Fenics/Test/resulta_stl/'

#we convert the files from fenics (that are .vtu) to .stl files:
converter(results_fenics, stl_converted)
